{"title":"C++ 类","uid":"a98ce169e82ba10a329e77dc3bdf4dba","slug":"C-类","date":"2023-03-11T08:45:00.000Z","updated":"2023-03-12T05:32:14.870Z","comments":true,"path":"api/articles/C-类.json","keywords":null,"cover":null,"content":"<h1 id=\"C-类\"><a href=\"#C-类\" class=\"headerlink\" title=\"C++ 类\"></a>C++ 类</h1><p>​        类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>，依赖于<strong>接口</strong>和<strong>实现</strong>分离的编程技术。用户只能使用接口而无法访问实现部分。</p>\n<h2 id=\"定义一个类\"><a href=\"#定义一个类\" class=\"headerlink\" title=\"定义一个类\"></a>定义一个类</h2><p>​        定义之前首先我们要设计出这个类，以Sales_data类为例，我们需要有以下接口：</p>\n<ul>\n<li>一个isbn成员函数，返回对象的ISBN编号。</li>\n<li>一个combine成员函数，用于将一个Sales_data对象加到另一个对象上。</li>\n<li>一个add函数，执行两个Sales_data的加法。</li>\n<li>一个read函数，将数据从istream读入到Sales_data对象中。</li>\n<li>一个print函数，将Sales_data对象输出到ostream。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Sales_data&#123;\n    public:\n        string isbn() const&#123; return bookNo;&#125;\n        Sales_data&amp; combine(const Sales_data&amp; );\n        double avg_price() const;\n    \tstring bookNo;\n    unsigned units_sold &#x3D; 0;\n    double revenue &#x3D; 0;\n    \n&#125;;</code></pre>\n<h2 id=\"类成员函数\"><a href=\"#类成员函数\" class=\"headerlink\" title=\"类成员函数\"></a>类成员函数</h2><h3 id=\"const成员函数\"><a href=\"#const成员函数\" class=\"headerlink\" title=\"const成员函数\"></a>const成员函数</h3><p>​        可以看到几个函数的形参列表后跟着一个const关键字，这是把this指针声明成为一个指向常量的指针，而this指针本身就是一个指针常量，所以下面这个例子中，this指针是一个指向常量的指针常量。this指针默认指向当前对象。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">string isbn() const &#123;\n    return this-&gt;bookNo;\n&#125;\n&#x2F;&#x2F;可以理解成\nstring isbn(const Sales_data * const this) &#123;\n    return this-&gt;bookNo;\n&#125;</code></pre>\n<p>​        而如果这个对象本身就是一个常量，那么这个对象只能调用常量成员函数。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Cat&#123;\n    public:\n        void meow1() const&#123;\n            printf(&quot;const meow~&quot;);\n        &#125;\n        void meow2() &#123;\n            printf(&quot;meow~&quot;);\n        &#125;\n&#125;;\n\nint main(int argc, char const *argv[])\n&#123;\n        const Cat mimi;\n        Cat miao;\n    \tmimi.meow1();&#x2F;&#x2F;正确，这是一个常量成员函数\n        mimi.meow2();&#x2F;&#x2F;报错，常量对象不能调用非常量成员函数\n        miao.meow1();&#x2F;&#x2F;正确\n    \tmiao.meow2();&#x2F;&#x2F;正确\n        return 0;\n&#125;</code></pre>\n<h3 id=\"外部成员函数\"><a href=\"#外部成员函数\" class=\"headerlink\" title=\"外部成员函数\"></a>外部成员函数</h3><p>​        类的成员函数定义在类的作用域之内，编译器先编译成员的声明，再编译成员函数体，所以不会因为前面的成员函数调用声明在后面的成员函数而报错。</p>\n<p>​        还可以在类的外部定义成员函数，但在函数名之前，需要加上作用域，并且返回类型，参数，函数名需要与类内部的声明保持一致。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Sales_data&#123;\n    public:\n        string isbn() const&#123; return bookNo;&#125;\n        Sales_data&amp; combine(const Sales_data&amp; );\n        double avg_price() const;\n    \tstring bookNo;\n    unsigned units_sold &#x3D; 0;\n    double revenue &#x3D; 0;\n    \n&#125;;\n\ndouble Sales_data::avg_price() const&#123;\n    if(units_sold)\n        return revenue&#x2F;units_sold;\n   \telse\n        return 0;\n&#125;</code></pre>\n<p>​         ::是作用域运算符，表示这个函数被声明在类Sales_data内。编译器看到函数名，就能理解这段代码是位于这个类的作用域内的，能够使用类中的成员。</p>\n<h3 id=\"返回this对象的成员函数\"><a href=\"#返回this对象的成员函数\" class=\"headerlink\" title=\"返回this对象的成员函数\"></a>返回this对象的成员函数</h3><p>​        在Sales_data中，有这样一个函数，返回的是一个对象。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Sales_data&amp; combine(const Sales_data &amp;rhs)&#123;\n    units_sold +&#x3D; rhs.units_sold;\n    revenue +&#x3D; rhs.revenue;\n    return *this;\n&#125;\nSales_data total,trans,shop;\ntrans.revenue &#x3D; 1;&#x2F;&#x2F;total.revenue &#x3D; 0\ntotal.combine(trans);&#x2F;&#x2F;total &#x3D; 1\nshop &#x3D; total.combine(trans);&#x2F;&#x2F;shop.revenue &#x3D; total.revenue &#x3D; 2</code></pre>\n<p>​        当我们调用combine函数的时候，total被绑定到this上，而ths被绑定到了trans上。return直接作用于this，也就是total。</p>\n<h3 id=\"定义类相关的非成员函数\"><a href=\"#定义类相关的非成员函数\" class=\"headerlink\" title=\"定义类相关的非成员函数\"></a>定义类相关的非成员函数</h3><p>​        我们需要定义一些辅助函数，比如add，read，print，这些函数的声明一般和类声明在同一个头文件中。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">istream &amp;read(istream &amp;is,Sales_data &amp;item)&#123;\n    double price &#x3D; 0;\n    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;\n    item.revenue &#x3D; price * item.units_sold;\n    return is;\n&#125;\n\nostream &amp;print(ostream &amp;os,const Sales_data &amp;item)&#123;\n    os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot;\n       &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price();\n    return os;\n&#125;</code></pre>\n<p>如果需要访问私有和被保护的成员，则需要设定为友元函数。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>​        构造函数没有返回类型，函数名与类名相同，不能声明为const。当我们设定一个对象为const的时候，当构造函数完成，这个对象才变为常量对象。</p>\n<p>​        如果没有显式声明构造函数，那么就会进行默认初始化，使用成员的初始值来初始化。但如果成员有指针成员这类需要显式初始化的，那么他们的值就是未定义的。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct Sales_data &#123;\n    Sales_data() &#x3D; default;&#x2F;&#x2F;默认构造函数\n    Sales_data(const std::string &amp;s):bookNo(s)&#123;&#125;&#x2F;&#x2F;带初始化列表的构造函数\n    Sales_data(const std::string &amp;s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n)&#123;&#125;\n    Sales_data(std::istream &amp;is);\n&#125;;\nSales::Sales_data(std::istream &amp;is)&#123;\n    read(is,*this);\n&#125;</code></pre>\n<p>​        在第二个构造函数中，没有被显式初始化的属性(revenue,units_sold)，被默认初始化了。</p>\n<h4 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h4>","feature":true,"text":"C++ 类​ 类的基本思想是数据抽象和封装，依赖于接口和实现分离的编程技术。用户只能使用接口而无法访问实现部分。 定义一个类​ 定义之前首先我们要设计出这个类，以Sales_data类为例，我们需要有以下接口： 一个isbn成员函数，返回对象的ISBN编号。 一个combine成...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E7%B1%BB\"><span class=\"toc-text\">C++ 类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB\"><span class=\"toc-text\">定义一个类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">类成员函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">const成员函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%96%E9%83%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">外部成员函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">返回this对象的成员函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">定义类相关的非成员函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">构造函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">拷贝构造函数</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"mapped":true,"prev_post":{"title":"几道位运算的题","uid":"115e88fbdb7de27d1adaee0a1c94eec9","slug":"位运算","date":"2023-03-12T11:36:00.000Z","updated":"2023-03-12T12:04:50.915Z","comments":true,"path":"api/articles/位运算.json","keywords":null,"cover":[],"text":"Leetcode 231 2的幂给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 bool isPowerOfTwo(int n) &#123;...","link":"","photos":[],"count_time":{"symbolsCount":826,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"feature":true},"next_post":{"title":"前缀和与差分","uid":"f65c2271ed43cdf14e2eea3c0c440d44","slug":"前缀和与差分","date":"2023-03-10T09:40:00.000Z","updated":"2023-03-10T10:30:16.589Z","comments":true,"path":"api/articles/前缀和与差分.json","keywords":null,"cover":[],"text":"前缀和与差分 例题523 连续的子数组给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组： 子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。 如果存在一个整...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}}}