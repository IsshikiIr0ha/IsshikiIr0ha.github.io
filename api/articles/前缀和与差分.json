{"title":"前缀和与差分","uid":"f65c2271ed43cdf14e2eea3c0c440d44","slug":"前缀和与差分","date":"2023-03-10T09:40:00.000Z","updated":"2023-03-10T10:30:16.589Z","comments":true,"path":"api/articles/前缀和与差分.json","keywords":null,"cover":[],"content":"<h1 id=\"前缀和与差分\"><a href=\"#前缀和与差分\" class=\"headerlink\" title=\"前缀和与差分\"></a>前缀和与差分</h1><p><img src=\"../images/image-20230310174302686.png\" alt=\"image-20230310174302686\"></p>\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><h2 id=\"523-连续的子数组\"><a href=\"#523-连续的子数组\" class=\"headerlink\" title=\"523 连续的子数组\"></a>523 连续的子数组</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>\n<ul>\n<li>子数组大小 <strong>至少为 2</strong> ，且</li>\n<li>子数组元素总和为 <code>k</code> 的倍数。</li>\n</ul>\n<p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。<code>0</code> 始终视为 <code>k</code> 的一个倍数。</p>\n<p>解法一，暴力解,将前缀和数组算出，再算出每一个子数组的值，依题目进行模运算。O(n^2)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;\n        vector&lt;int&gt; sum(nums.size()+1);\n        for(int i &#x3D; 1;i &lt; sum.size();i++)&#123;\n            sum[i] &#x3D; nums[i-1] + sum[i-1];\n        &#125;\n        for(int left &#x3D; 0;left &lt; nums.size();left++)&#123;\n            for(int right &#x3D; left+1;right &lt; sum.size();right++)&#123;\n                int x &#x3D; sum[right]-sum[left];\n                if(x%k &#x3D;&#x3D; 0 &amp;&amp; right-left&gt;&#x3D;2)&#123;\n                    return true;\n                &#125;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n<p>解法二，前缀和加哈希表法。这里需要用到同余定理。</p>\n<p><img src=\"../images/image-20230310182836278.png\" alt=\"image-20230310182836278\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int sum &#x3D; 0;\n        unordered_map&lt;int,int&gt; m;&#x2F;&#x2F;余数作key，index作为value\n        m[0] &#x3D; -1;\n        for(int i &#x3D; 0;i &lt; nums.size();i++)&#123;\n            sum &#x3D; (sum + nums[i])%k;&#x2F;&#x2F;由于余数只和个位有关系，直接取模\n            if(m.find(sum) !&#x3D; m.end())&#123;&#x2F;&#x2F;判断同余\n                if(i - m[sum] &gt;1)&#123;\n                    return true;\n                &#125;\n            &#125;\n            else&#123;\n                m[sum] &#x3D; i;&#x2F;&#x2F;当前余数不存在，加入哈希表\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>","feature":true,"text":"前缀和与差分 例题523 连续的子数组给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组： 子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。 如果存在一个整...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86\"><span class=\"toc-text\">前缀和与差分</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">例题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#523-%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">523 连续的子数组</span></a></li></ol></li></ol>","author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"基础算法模板(1)","uid":"d4eb8ac478f9b1540ad79d6e8d3f28dd","slug":"基础算法模板-1","date":"2023-03-09T11:06:00.000Z","updated":"2023-03-10T09:45:21.399Z","comments":true,"path":"api/articles/基础算法模板-1.json","keywords":null,"cover":[],"text":"快排void quick_sort(int q[],int l,int r)&#123; if (l&gt;&#x3D;r)&#123; &#x2F;&#x2F;判断输入错误和数组大小为1 return; &#125; int x &#x3D; q[(l+r)&gt;&gt;1]...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"feature":true}}