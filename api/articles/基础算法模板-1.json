{"title":"基础算法模板(1)","uid":"d4eb8ac478f9b1540ad79d6e8d3f28dd","slug":"基础算法模板-1","date":"2023-03-09T11:06:00.000Z","updated":"2023-03-10T09:45:21.399Z","comments":true,"path":"api/articles/基础算法模板-1.json","keywords":null,"cover":[],"content":"<h1 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void quick_sort(int q[],int l,int r)&#123;\n    if (l&gt;&#x3D;r)&#123; &#x2F;&#x2F;判断输入错误和数组大小为1\n        return;\n    &#125;\n    int x &#x3D; q[(l+r)&gt;&gt;1], i &#x3D; l - 1, j &#x3D; r + 1;\n    while(i &lt; j)&#123;\n        do&#123;\n            i++;\n        &#125; while (q[i] &lt; x);\n        do&#123;\n            j--;\n        &#125; while (q[j] &gt; x);\n        if(i &lt; j)&#123;\n            swap(q[i], q[j]);\n        &#125;\n    &#125;\n    quick_sort(q, l, j);&#x2F;&#x2F;j变成i-1，那x不能取q[l],写j不能取q[r]，所以统一取(l+r)&#x2F;2\n    quick_sort(q, j+1, r);\n&#125;\n</code></pre>\n<p>为什么当x=q[l]，递归把j换成i的时候可能会导致死循环？</p>\n<p><img src=\"../images/image-20230310121647604.png\" alt=\"image-20230310121647604\"></p>\n<p>当x=q[r]，则递归的右边界不能取j，原因也是一样。</p>\n<p><img src=\"../images/image-20230310122806751.png\" alt=\"image-20230310122806751\"></p>\n<h1 id=\"二分归并排序\"><a href=\"#二分归并排序\" class=\"headerlink\" title=\"二分归并排序\"></a>二分归并排序</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void merge_sort(int q[],int l,int r)&#123;\n    if(l &gt;&#x3D; r)\n        return ;\n    int mid &#x3D; (l+r)&gt;&gt;1;\n    merge_sort(q,l,mid);\n    merge_sort(q,mid+1,r);\n    int i &#x3D; l,j &#x3D; mid+1,k &#x3D; 0;\n    while(i &lt;&#x3D;mid &amp;&amp; j &lt;&#x3D;r)&#123;\n        (q[i] &lt;&#x3D; q[j])&#123;\n            temp[k++] &#x3D; q[i++];\n        &#125;\n        else&#123;\n            temp[k++] &#x3D; q[j++];\n        &#125;\n    &#125;\n    while(i&lt;&#x3D;mid)&#123;\n        temp[k++] &#x3D; q[i++];\n    &#125;\n    while(j&lt;&#x3D;r)&#123;\n        temp[k++] &#x3D; q[j++];\n    &#125;\n    for(i &#x3D; l,j &#x3D; 0;i &lt;&#x3D;r;i++,j++)\n        q[i] &#x3D; temp[j];&#x2F;&#x2F;当次排序结果写回数组\n&#125;</code></pre>\n<h1 id=\"寻找边界的二分\"><a href=\"#寻找边界的二分\" class=\"headerlink\" title=\"寻找边界的二分\"></a>寻找边界的二分</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int Left(vector&lt;int&gt;&amp; nums,int target)&#123;\n        int left &#x3D; 0,right &#x3D; nums.size()-1;\n        while(left &lt; right)&#123;\n            int mid &#x3D; left+(right-left)&#x2F;2;\n            if(nums[mid]&gt;&#x3D;target)&#123;\n                right &#x3D; mid;\n            &#125;\n            else&#123;\n                left &#x3D; mid +1;\n            &#125;\n        &#125;\n        if(nums[left] !&#x3D; target)&#123;\n            return -1;\n        &#125;\n        else\n            return left;\n    &#125;\nint Right(vector&lt;int&gt;&amp; nums,int target)&#123;\n        int left &#x3D; 0,right &#x3D; nums.size()-1;\n        while(left &lt; right)&#123;\n            int mid &#x3D; left + (right-left)&#x2F;2+1;\n            if(nums[mid]&lt;&#x3D;target)&#123;\n                left &#x3D; mid;\n            &#125;\n            else&#123;\n                right &#x3D; mid-1;\n            &#125;\n        &#125;\n        if(nums[left] !&#x3D; target)&#123;\n            return -1;\n        &#125;\n        else\n            return left;\n    &#125;</code></pre>\n","text":"快排void quick_sort(int q[],int l,int r)&#123; if (l&gt;&#x3D;r)&#123; &#x2F;&#x2F;判断输入错误和数组大小为1 return; &#125; int x &#x3D; q[(l+r)&gt;&gt;1]...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E6%8E%92\"><span class=\"toc-text\">快排</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">二分归并排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AF%BB%E6%89%BE%E8%BE%B9%E7%95%8C%E7%9A%84%E4%BA%8C%E5%88%86\"><span class=\"toc-text\">寻找边界的二分</span></a></li></ol>","author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"mapped":true,"prev_post":{"title":"前缀和与差分","uid":"f65c2271ed43cdf14e2eea3c0c440d44","slug":"前缀和与差分","date":"2023-03-10T09:40:00.000Z","updated":"2023-03-10T10:30:16.589Z","comments":true,"path":"api/articles/前缀和与差分.json","keywords":null,"cover":[],"text":"前缀和与差分 例题523 连续的子数组给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组： 子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。 如果存在一个整...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}},"next_post":{"title":"环形链表题","uid":"7e07234faada42c308f491eefec54e74","slug":"环形链表题","date":"2023-02-25T15:05:00.000Z","updated":"2023-02-25T23:48:24.132Z","comments":true,"path":"api/articles/环形链表题.json","keywords":null,"cover":[],"text":"141.环形链表I，142.环形链表II141.环形链表I给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","count":5,"path":"api/tags/Leetcode.json"},{"name":"链表","slug":"链表","count":3,"path":"api/tags/链表.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}}}