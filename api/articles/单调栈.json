{"title":"单调栈","uid":"0614f2a1b2d44b47b9d291cad158b954","slug":"单调栈","date":"2023-03-18T16:40:00.000Z","updated":"2023-03-18T16:42:06.243Z","comments":true,"path":"api/articles/单调栈.json","keywords":null,"cover":[],"content":"<hr>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>单调栈常常用于寻找离元素最近的一个比当前值大(小)的元素，若我们需要寻找比当前nums[i]下一个更大的元素，则需要从右往左遍历，由于栈后进先出的特性，nums[i]右边的数会在栈顶。我们需要维持一个递增栈(从栈顶到栈底递增)，保证栈里的数比当前数大，就需要当nums[i] &gt;= stack.top的时候，将所有比nums[i]小的数弹出，又因为栈的特性，栈顶的元素就是比nums[i]大的最近一个元素。</p>\n<p>若我们需要寻找比当前Nums[i]前一个更大的元素，就需要从左向右遍历，原理同上。</p>\n<p><img src=\"../images/image-20230318215700414.png\" alt=\"image-20230318215700414\"></p>\n<p>基础代码模板如下(下一个更大的元素)</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int size &#x3D; nums.size();\nstack&lt;int&gt; st;\nvector&lt;int&gt; res (nums.size());\nfor(int i &#x3D; size-1;i &gt;&#x3D; 0;i--)&#123;\n    while(!st.empty()&amp;&amp;nums[i] &gt;&#x3D; st.top())&#123;\n        st.pop();\n    &#125;\n    res[i] &#x3D; st.empty()? -1:st.top();\n    st.push(nums[i]);\n&#125;\n</code></pre>\n","feature":true,"text":" 原理单调栈常常用于寻找离元素最近的一个比当前值大(小)的元素，若我们需要寻找比当前nums[i]下一个更大的元素，则需要从右往左遍历，由于栈后进先出的特性，nums[i]右边的数会在栈顶。我们需要维持一个递增栈(从栈顶到栈底递增)，保证栈里的数比当前数大，就需要当nums[i]...","link":"","photos":[],"count_time":{"symbolsCount":577,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","count":5,"path":"api/tags/Leetcode.json"},{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li></ol>","author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"几道位运算的题","uid":"115e88fbdb7de27d1adaee0a1c94eec9","slug":"位运算","date":"2023-03-12T11:36:00.000Z","updated":"2023-03-12T12:04:50.915Z","comments":true,"path":"api/articles/位运算.json","keywords":null,"cover":[],"text":"Leetcode 231 2的幂给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 bool isPowerOfTwo(int n) &#123;...","link":"","photos":[],"count_time":{"symbolsCount":826,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"feature":true}}