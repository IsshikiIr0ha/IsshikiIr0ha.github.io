{"title":"环形链表题","uid":"7e07234faada42c308f491eefec54e74","slug":"环形链表题","date":"2023-02-25T15:05:00.000Z","updated":"2023-02-25T23:48:24.132Z","comments":true,"path":"api/articles/环形链表题.json","keywords":null,"cover":[],"content":"<h1 id=\"141-环形链表I，142-环形链表II\"><a href=\"#141-环形链表I，142-环形链表II\" class=\"headerlink\" title=\"141.环形链表I，142.环形链表II\"></a>141.环形链表I，142.环形链表II</h1><h2 id=\"141-环形链表I\"><a href=\"#141-环形链表I\" class=\"headerlink\" title=\"141.环形链表I\"></a>141.环形链表I</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>\n<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>\n<p>这里给出一个判定方法，Floyd判定法，使用一对快慢指针，若存在环，那么两个指针必然在某节点相遇，代码实现如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool hasCycle(ListNode *head) &#123;\n        ListNode* fast &#x3D; head,*slow &#x3D; head;\n        while(fast &amp;&amp; fast-&gt;next)&#123;\n            fast &#x3D; fast-&gt;next-&gt;next;\n            slow &#x3D; slow-&gt;next;\n            if(fast &#x3D;&#x3D; slow)&#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n<h2 id=\"142-环形链表II\"><a href=\"#142-环形链表II\" class=\"headerlink\" title=\"142.环形链表II\"></a>142.环形链表II</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n<p><strong>不允许修改</strong> 链表。</p>\n<p>和上一题的区别是，我们需要返回入环的第一个结点。思路如下：</p>\n<ol>\n<li><p>判断是否存在环路，无环直接返回null</p>\n</li>\n<li><p>若有环，找出环入口，这里有两种方法：</p>\n<ul>\n<li>使用哈希表记录每个结点，遍历结点时查询是否已经在HashMap里。</li>\n<li>使用数学方法，推导如下：</li>\n</ul>\n<p><img src=\"../images/meet.png\" alt=\"meet\"></p>\n</li>\n</ol>\n<p><img src=\"../images/image-20230225233925657.png\" alt=\"image-20230225233925657\"></p>\n<p>慢指针一定没转完一圈就相遇，详细的数学推导这里不给出，这里简单说一下，假设fast，slow已经在环内某个位置，当slow下一次走了一圈走到同样位置的时候，fast走了两圈，是一定覆盖slow走的所有可能路径的，所以slow=x+y，这里给出一张草图。</p>\n<p><img src=\"../images/image-20230225235046686.png\" alt=\"image-20230225235046686\"></p>\n<p>因此我们设定一个指针从头结点开始，和slow同步移动，他们必在环开端相遇。下面给出代码。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        ListNode* fast &#x3D; head,*slow &#x3D; head;\n        do&#123;\n            if(!fast || !fast-&gt;next)\n                return nullptr;\n            fast &#x3D; fast-&gt;next-&gt;next;\n            slow &#x3D; slow-&gt;next;\n        &#125;while(fast !&#x3D; slow);\n        ListNode* ptr &#x3D; head;\n        while(ptr !&#x3D; slow)&#123;\n            ptr &#x3D; ptr-&gt;next;\n            slow &#x3D; slow-&gt;next;\n        &#125;\n        return ptr;\n    &#125;\n&#125;;</code></pre>\n","text":"141.环形链表I，142.环形链表II141.环形链表I给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","count":5,"path":"api/tags/Leetcode.json"},{"name":"链表","slug":"链表","count":3,"path":"api/tags/链表.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8I%EF%BC%8C142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II\"><span class=\"toc-text\">141.环形链表I，142.环形链表II</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8I\"><span class=\"toc-text\">141.环形链表I</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II\"><span class=\"toc-text\">142.环形链表II</span></a></li></ol></li></ol>","author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"mapped":true,"prev_post":{"title":"基础算法模板(1)","uid":"d4eb8ac478f9b1540ad79d6e8d3f28dd","slug":"基础算法模板-1","date":"2023-03-09T11:06:00.000Z","updated":"2023-03-10T09:45:21.399Z","comments":true,"path":"api/articles/基础算法模板-1.json","keywords":null,"cover":[],"text":"快排void quick_sort(int q[],int l,int r)&#123; if (l&gt;&#x3D;r)&#123; &#x2F;&#x2F;判断输入错误和数组大小为1 return; &#125; int x &#x3D; q[(l+r)&gt;&gt;1]...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}},"next_post":{"title":"2.两数之和","uid":"ccde5a49b40a5476a862c22787b0daae","slug":"2-两数之和","date":"2023-02-25T14:50:00.000Z","updated":"2023-02-25T14:56:45.249Z","comments":true,"path":"api/articles/2-两数之和.json","keywords":null,"cover":[],"text":"2.两数之和题目：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 分析：简单题，按所给示例，因为...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","count":5,"path":"api/tags/Leetcode.json"},{"name":"链表","slug":"链表","count":3,"path":"api/tags/链表.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}}}