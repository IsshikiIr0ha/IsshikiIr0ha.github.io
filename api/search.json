[{"id":"4eed6726322cbd1240d9eae47dec8b49","title":"网络信息安全","content":"密码学第二章密码学基本术语​\t\tKey：密钥，对加密和解密过程进行控制的参数。\n​\t\tCipher：加密方法。\n​\t\tEncipher：加密。将明文转换为密文。\n​\t\tDecipher：解密。将密文还原成明文。\n​\t\tPlaintext：明文。\n​\t\tCiphertext：密文。\n​\t\t大多数加密算法、解密算法是公开的。密钥来保证算法的安全性。密钥是不公开的。\n​\t\t理论安全：攻击者无论截获多少密文，都无法得到足够的信息来唯一地决定明文。Shannon证明，如果想要达到理论安全，密钥长度要大于等于明文长度，并且一次一密，用完即丢。这种是不现实的。\n​\t\t实际安全：如果攻击者有无限资源，任何密码系统都是可以被破译的，但是在有限资源内，攻击者都不能通过系统的分析方法来破解系统，则称这个系统是计算上安全的。现有的商用密码都是实际安全的。\n​\t\t加密系统可以用数学符号来描述。\n​\t\tS &#x3D; {P,C,K,E,D}。这五个分别是，明文空间，密文空间，密钥空间，加密变换，解密变换。如果对数字加密，那明文空间就是0~9。\n​\t\t对称式密码体制：加密和解密所用密钥是相同的。开放性差。\n​\t\t非对称密码体制：加密和解密是分开的，开放性好。\n​\t\t序列密码体制：加密以比特为单位，密文不仅与算法和密钥有关，也和明文位置有关。\n​\t\t分组密码体制：加密以组为单位，与明文位置无关。明文长度和密文长度相同。\n​\t\t确定型密码体制：明文和密钥确定后，密文也确定了。\n​\t\t概率密码体制：明文和密钥确定后，密文通过客观随机因素从密文集合中产生，密文形式不确定。\n​\t\t单向函数型密码体制：适用于不需要解密的场合，容易将明文加密成密文。如哈希函数。\n​\t\t双向变换型密码体制：加密解密可逆。\n对称密码系统的模型​\t\t收发双方必须在某种安全的形式下获得密钥并必须保证密钥的安全。\n​\t\t基本要求：强加密算法，只有双方知道的密钥。因此必须有一个安全的途径或信道分发密钥。\n​\t\t将明文转换为密文和操作类型：代换和置换。代换是用另一个元素来代替，置换是对顺序进行重新排序。\n​\t\t对加密信息攻击的类型：\n​\t\t唯密文攻击：捕获密文。\n​\t\t已知明文攻击：一段时间明文解密，攻击者得到一些明文密文对应关系，仍然不能破解。\n​\t\t选择明文攻击：对于已知明文攻击有了选择性。攻击者可以主动选择明文询问，得到需要的明文密文。\n​\t\t选择密文攻击：发送密文，准备密文更难。\n​\t\t选择文本攻击：包括了第三第四条。\nDES​\t\tDES(数据加密标准)的分组和密钥是64位和56位，扩展了Feistel密码结构。\n​\t\t混淆：希望密文和密钥的关系尽量复杂。\n​\t\t扩散：明文统计结构扩散消失到大批密文统计特性中，例如改变明文1bit，密文多余1bit改变。\nFeistel结构​\t\tFeistel结构是对称的，除第一轮外，每一轮的左边都是上一轮右边的输出(代换)，右边则是Ri &#x3D; Li-1 ^ F(ki , Ri-1)。典型轮数是16轮。128位是常用密钥长度。解密时，输入密文，以相反的次序使用密钥。\nDES流程​\t\t输入明文和密钥，根据初始置换表进行初始置换，将指定位置i上的值置换到指定位置j上(在原有明文上打乱顺序)。恢复时根据逆置换。\n​\t\t扩充置换，根据扩充置换表将原有数据扩充，DES中是左右部各扩充8位。(这一步完成了混淆和扩散)。\n​\t\t56位密钥分为左右两部分，先循环左移，再通过P置换和收缩得到48位子密钥。\n​\t\t将32位右半部和48-bit子密钥做如下操作(F函数)：\n​\t\t使用扩充置换表E，将32位右半部扩充成48位。\n​\t\t与子密钥异或。\n​\t\t48位结果送进8个替换盒(将6位映射成4位)，得到32位，再用32位置换表P进行置换。S盒映射，外侧1和6位用作行选择，其余用作列选择。例如110011，定位于第三行第九列，作用于盒8，则得到的数据是12，也就是1100。\n​\t\t之后与上一轮的左部进行异或，得到下一轮的右部。\n多重加密​\t\t穷举攻击对于DES是可行的。\n​\t\t对称密码有5种工作模式。\n双重DES​\t\t先用K1、K2加密，再用K2、K1解密，密钥长度是112位。但用中途相遇攻击能破解，实际上破解复杂度并没有因为密钥复杂度的提升而提升。可以穷举K1,K2，中间值X &#x3D; Ek1(M) &#x3D; Dk2(C)。\n​\t\t\n三重DES\n    用两个密钥进行E-D-E\n    用三个密钥进行E-D-E\n\n\nAES​\t\t高级加密标准。\n加密模式​\t\t1.电子密码本模式(ECB)，分组之后用同一密钥进行加密，相同明文得到相同密文。\n​\t\t2.密文分组链接模式(CBC)，加密输入是当前明文和前一组密文进行异或，之后再用密钥加密。第一组需要有一个初始向量和初始明文进行异或。解密是用密文与密钥作用，之后和前一组密文异或。IV不能明文传送给接收方。因为DES是有扩散性和混淆的，没有办法通过改变密文来改变明文里的指定比特，因为扩散性，这样就知道密文被破坏了。我们要阻止攻击者对指定比特进行改变，例如攻击者把你的薪水50000改成50(😀)。但明文混乱，就能识别出来密文被改变(薪水变成500ab一眼真)。如果攻击者获得IV，就能直接对第一组明文进行指定比特改变(因为是异或操作)。\n​\t\t3.密码反馈模式(CFB)，将DES转化成流密码(逐比特)。优点是转换成流密码。缺点是如果工作出现差错，例如C1错，解密会导致P1错，而C1又要注入到下一步P2的解密，就会导致后面的明文解密全部出错。也就是比特差错会传播。\n​\t\t4.输出反馈模式(OFB)，不同于CFB，OFB是加密函数的输出到下一次加密，CFB是密文输出到下一轮加密。即使C1错，只会影响到P1，防止比特差错的传播。但缺点也很明显，更容易受到报文流篡改攻击。通过修改密文，可以修改指定比特，对明文中的某些比特进行改变。(和CBC很像)为什么CFB不容易受影响，是因为CFB的比特差错会传播，C1被篡改会影响后续。\n​\t\t5.计数器模式(CTR)，和OFB很像，但加密的是计数器的值。应用于高速网络，因为这个方向可以并行，非常高效。不重复使用密钥和计数器值。\n单向函数​\t\t给x容易求y，给y不容易推x。\n​\t\t单项陷井门函数，除非给陷门，不然给x容易求y，给y不容易推x。可以类比，有x求y是加密，有y推x是解密，暗门就是密钥。\n公钥密码思想​\t\t对称密码体制的问题：\n​\t\t加解密能力捆绑在一起。\n​\t\t密钥更换、传递和交换需要可靠信道，密钥分发困难。\n​\t\t如果有N个用户，需要N(N-1)&#x2F;2个密钥。\n​\t\t无法满足两个不相识的人之间的通信，因为在通信之前需要有一模一样的密钥。(根本问题)\n​\t\t不能实现数字签名。\n​\t\t非对称的特点：\n​\t\t加解密能力分开。\n​\t\t密钥分发简单。\n​\t\t保存密钥量大大减少，N个用户只需要N个。\n​\t\t满足不相识的人之间保密通信。\n​\t\t实现数字签名。\n​\t\t公钥算法的步骤：\n​\t\t每个用户产生一对密钥，用来加密解密。\n​\t\t将公钥公开，另一个密钥私有，每个用户可以拥有若干其他用户的公钥。\n​\t\tBob发消息给Alice，就要用Alice的公钥加密。Alice收到消息后，用自己的私钥解密，其他人均不能解密。\n​\t\t需要认证时，示证方用自己的私钥加密消息(签名)。验证方用示证方的公钥解密(验证)。就可以证明发送方的身份。\n​\t\t加密和认证结合起来，实现了保密性和认证。\n​\t\t公钥算法应用：加解密，签名，给对称式加密输送密钥。\n​\t\t对编码系统的要求：\n​\t\t产生一对密钥，容易。\n​\t\t加解密，较容易。\n​\t\t知道公钥(Ke)算私钥(Kd)，不行。\n​\t\t不知道私钥，其他都知道，也不能算明文。\n​\t\tD(E(m)) &#x3D; E(D(m))。\n​\t\t公钥密码的分析：\n​\t\t公钥密码易受穷举密钥攻击，方法是用长密钥。同时希望便于加解密，又需要密钥短，所以目前仅限于密钥管理和签名。\n​\t\t从算法上分析从公钥算出私钥，并没有证明不可行，所以值得怀疑。\n​\t\t穷举消息攻击，攻击者用公钥对所有可能的消息加密，与密文匹配。可以在消息后附加随机数。\nRSA​\t\t流程：\n​\t\t随机选择两个大素数p，q。\n​\t\t计算公开模式n &#x3D; p*q。\n​\t\t计算欧拉函数φ(n) &#x3D; (p-1)(q-1)。\n​\t\t选择一个与φ(n) 互素的数，作为e或d。\n​\t\t根据扩展Euclid算法，求e或d的乘法逆元，即ed mod φ(n) &#x3D; 1。\n​\t\t加密，C&#x3D;M^e mod n。\n​\t\t解密, M &#x3D; C^d mod n &#x3D; (M^e mod n)^d mod n &#x3D; M\n公钥分配​\t\t公钥算法计算开销大，而且需要正确拿到对方的公钥。\n​\t\t公开广播最大的问题就在于任何人都可以伪造公钥的发布。\n​\t\t有几种方式：公开广播，公开可访问目录，公钥授权，公钥证书。\n​\t\t公开可访问目录的私钥一旦丢失，攻击者就可以假冒任何通信方。\n公钥授权​\t\t公钥授权机构发送Request和时间戳的原因：A给机构的信息是明文传送，可以被截获并改动。如果攻击者改动，要C的公钥，A和机构是不知道的。所以传回Request是防止篡改攻击。时间戳是保证B公钥更新后，私钥可能泄露，机构回传消息可能被捕获，隔一段时间A又要和B通信，攻击者可以拦截机构返回的消息，重放上次时间的消息，进行重放攻击。\n​\t\tN1,N2的意义：进行认证。因为任何一个用户都可以申请A的公钥并向A发送消息。A用B的公钥加密发送N1,B用A的公钥加密发送N1认证，并发送N2，A接收后再用B的公钥加密发回N2证明自己是A。\n​\t\t缺点：PKA要实时在线。PKA是系统的瓶颈。\n\n\n公钥证书​\t\t使得不通过实时访问PKA完成公钥交换。CA，证书授权中心，CA用自己的私钥签署证书后就能下线。双方拿到各自的证书后，想要通信，直接发送各自的证书，然后用CA的公钥解密证书，解密成功，证明证书合法，之后就可以获取对方公钥进行通信。\n公钥分配传统密码​\t\t在实际中，往往是公钥算法和传统密码结合的方式。\n简单的密钥分配​\t\tA产生公钥私钥，将公钥和自己的ID发送给B，B用A的公钥发送一个秘密密钥。容易遭受中间人攻击。可以将A的消息拦截，篡改公钥后发送给B。之后又将B的消息拦截，用自己的私钥解密，看到KS，之后再用KUa加密B的消息发给A，A和B的通信就暴露在攻击者的观察下了。\n保密、真实的密钥分配​\t\t假设双方通过安全的方法拿到对方的公钥。\n​\t\t安全漏洞：第四条消息可以重放。攻击者捕获第四条消息，会话密钥过一段时间就会泄露，Ks就会暴露。可以把3，4消息进行合并(加一个随机数)。\nDiffie-Hellman密钥交换​\t\t是一种公钥分发机制。不能抵抗中间人攻击。\nEIGamal​\t\t基于DLP的概率密码系统。明文密钥一样，生成的密文也不一样。缺点是传输的密文是明文的2倍。\n消息认证和哈希函数​\t\t消息认证是验证消息完整性的，确保收到数据和发送时一样，且发送方声称的身份是真实的。\n帧校验序列​\t\t每个消息附加一个FCS，FCS和加密函数执行的顺序很重要。这是为了解决明文可能难以识别的情况。\n消息验证码​\t\t独立使用MAC，需要有一个秘密密钥。不可以实现不可否认性和机密性。实现了认证性和完整性。不提供数字签名！\n散列函数​\t\t\n​\t\t不需要密钥，任何人都可以计算。\t\t\n​\t\t见PPT中第一个图，实现了机密性和一定程度的认证性。不能实现不可否认性。\n​\t\t第二个图，没有实现机密性。接收方自己计算哈希值，和解密后的哈希值比较。在本例中，H必须加密，防止M和H被篡改。攻击者可以篡改M，计算H‘后替换H。\n​\t\t第三个图，发送方计算H后用自己私钥加密，之后并上M发给接收方。接收方用发送方公钥解密。实现不可否认性。\n​\t\t\n​\t\t第四个图，实现了保密性(对称式加密)、认证性，不可否认性(数字签名)、消息完整性(数字签名和散列函数)。我们很少用KRa(私钥)直接加密明文，因为公钥算法开销非常大，而哈希值(128bit)是固定长度。而且哈希函数抗碰撞性好，明文不一样，哈希值绝大多数情况下不同，如果有，也很难用数学方法找到，所以近似看成一对一，所以才有不可否认性。\n​\t\t第五种，如果我们提前协商好一个S，接收方就可以认为是指定发送方发送的。没有实现不可否认性。但S是单向的，可以重复使用。\n​\t\t第六种相比第五种，对M进行了加密。\n数字签名和认证协议​\t\t数字签名可以不是实时的。\n​\t\t认证服务包括身份认证和报文认证。\n​\t\tPPT中的EIGamal的数字签名。\nKerberos和X.509​\t\tKerberos，提供一个集中的授权服务器负责用户和服务器之间的身份认证。仅仅依赖对称加密体制。\n​\t\t用户和服务器都需要去Kerberos服务器注册。服务器和AS共享对称式密钥，AS和用户共享口令。\nTGS​\t\t最初是用户和AS共享一个密钥，TGS和V共享一个，TGS和AS共享一个。AS传回给用户的票据是用TGS和AS的密钥加密的。TS5+1是用户C对V的一个认证。\nX.509​\t\t证书不可以伪造，因为改了之后你没有私钥无法还原。\n","slug":"网络信息安全","date":"2023-02-23T08:53:00.000Z","categories_index":"","tags_index":"密码学,网络安全","author_index":"iroha"},{"id":"6fc8774f334f99b8964d2d8c2cdc313c","title":"SQL","content":"基于MySQL的极入门笔记简介DB DBMS SQL之间的关系：\n​\t\tDB是Data Base，是数据库的缩写，在硬盘上以文件的形式存在。DBMS是Data Base Management System（数据库管理系统）的缩写，例如MySQL、Oracle、DB2等就是一个DBMS，来管理DB中的数据。而SQL（结构化查询语言）是一种高级语言，编译由DBMS完成。简而言之，DBMS通过执行SQL语句来操作DB中的数据。\n表(table)​\t\t是数据库的基本组成单元，由表组织数据，可读性强。一个表包括行和列。行被称为数据&#x2F;记录，列被称为字段(column)。\n\n\n\n学号(int)\n姓名(varchar)\n年龄\n\n\n\n110\n张三\n20\n\n\n120\n李四\n21\n\n\n​\t\t字段应该包括字段名、数据类型和相关的约束(例如要求字段不能为空)。例如上表中有学号字段、姓名字段和年龄字段。\nSQL语句分类DQL：数据查询语言，查询语句，凡是select语句都是DQL。\nDML：数据操作语言，例如insert delete update语句，对表中数据进行增删改。\nDDL：数据定义语言，例如create drop alter语句，对表的结构进行增删改\nTCL：事务控制语言，commit提交事务，rollback回滚事务。\nDCL：数据控制语言，例如grant授权，revoke撤销权限。\n程序员在编写SQL语句式，一般将关键字置为大写，其余为小写。\n选择语句​\t\tUSE关键字可以用来选择数据库，例如USE sql.store，在Mysql中可以双击来选中数据库。\n​\t\tSELECT  column1,column2…..来选中你想选中的字段。\n又或者是SELECT * 来选择所有字段。\n​\t\tFROM table，来选中你想要选择的表格。可以将SELECT语句和FROM语句放在一行，但当数据库中的数据逐渐变多，这样的会让SQL语句段的可读性变差，所以尽量还是将SQL语句单独分行。也可以直接在FROM语句中指定数据库，例如\nFROM sql_store.customers\n\n\n\n​\t\tWHERE column1 &#x3D; ***，可以选择字段1中值为对应值的数据。\n​\t\tORDER BY column1 能够以column1为依据对数据进行排序\n​\t\t以下是一段简单的SQL：\nUSE sql_store;&#x2F;&#x2F;选择Sql_store这个数据库\nSELECT *  &#x2F;&#x2F;选中sql_store中所有的字段\nFROM customers &#x2F;&#x2F;选中sql_store中的customers表格\nWHERE customer_id &#x3D; 1 &#x2F;&#x2F;选中customer_id为顾客\n\n​\t\t在Windows平台上，Mysql的编译&#x2F;执行快捷键是Ctrl+shift+enter。\nSELECT​\t\t如果我们想要从表格中获取指定的字段，可以使用SELECT语句。例如SELECT first_name,last_name,注意，DBMS中字段显示的顺序是与你输入的字段顺序相关的。\n\n\n\nfirst_name\nlast_name\n\n\n\nSELECT first_name,last_name\n\n\n\n\n\n\nlast_name\nfirst_name\n\n\n\nSELECT last_name,first_name\n\n​\t\t在SELECT语句中，可以写入一个关于字段的数学表达式，例如SELECT point + 10，就能列出表格中的point项 + 10后的数据，并且可以用AS来给这个新字段取名。例如：\nSELECT first_name,point +10 AS &#39;discount price&#39;\n\n​\t\t在这段语句中，AS关键字给point + 10这一字段取了一个discount price的别名，使用单引号能够让别称带有空格。\n​\t\tDISTINCT关键字能够取出该字段所有的不同数据，舍去重复的数据。\n​\t\tWHERE condition 能够筛选出符合条件的数据，使用关系运算符，需要注意的是，不等于(note equal)可以使用**&lt;&gt;和!&#x3D;来表示，而相等则是&#x3D;，如果条件中有字符串，那么字符串需要用‘  ‘**包含，值得一提的是，日期也需要以字符串来对待，即使他是一串数字，例如’1990-01-02’。\n​\t\t如果有多个条件，那么可以使用逻辑运算符AND,OR,NOT，他们的用法显而易见，并且遵循NOT&gt;AND&gt;OR的优先级。\n​\t\tIN关键字可以简化一串OR条件语句，请看下面的例子：\nSELECT * \nFROM customers\nWHERE state &#x3D; &#39;VA&#39; OR state &#x3D; &#39;FL&#39; OR state &#x3D; &#39;GA&#39;\n--不能写成state &#x3D; &#39;VA&#39; OR &#39;FL&#39; OR &#39;GA&#39;的原因是，state &#x3D; &#39;VA&#39;这类语句的结果会得到一个布尔值用于判断，该剧中需要三个布尔值来确定最终值，而state &#x3D; &#39;VA&#39; OR &#39;FL&#39; OR &#39;GA&#39;无法实现。\n--简化后\nSELECT *\nFROM customers\nWHERE state IN(&#39;VA&#39;,&#39;FL&#39;,&#39;GA&#39;)\n\n​\t\t同样的，如果想要得到给定范围之外的结果，只需要在IN前加上NOT,例如：\nWHERE state NOT IN(&#39;VA&#39;,&#39;FL&#39;,&#39;GA&#39;)\n\n​\t\tBETWEEN关键字可以简化AND语句，该关键字包含临界值。例子如下：\nWHERE points &gt;&#x3D;1000 AND points &lt;&#x3D;3000\n--\nWHERE points BETWEEN 1000 AND 3000\n\n​\t\t如果我们只想要以某个字符或者某个字符串开头的字段数据，又或者是包含某个字符的数据，可以使用LIKE关键字。例如：\nWHERE last_name LIKE &#39;b%&#39; \n--姓氏以b开头的数据\nWHERE last_name LIKE &#39;BRUSH%&#39;\n--姓氏以brush开头的数据\nWHERE last_name LIKE &#39;%B%&#39;\n--姓氏中包含b的数据\nWHERE last_name LIKE &#39;%B&#39;\n--姓氏中以B为结尾的数据\nWHERE last_name LIKE &#39;_y&#39;\n--姓氏只包含两个字符并且第二个是y的数据,_代表一个字符。\nWHERE last_name LIKE &#39;b_y&#39;\n--姓氏只包含三个字符并且第一个是b，第三个是y的数据,_代表一个字符。\n\n​\t\t以上的用法是比较古老的寻找包含相应字符串的数据的方法，通过这种方法可以找到任何你想要的数据。\n​\t\t一种新方法，就是使用REGEXP，是正则表达式的缩写，允许搜索更复杂的形式。\nWHERE last_name LIKE &#39;%FIELD%&#39;\nWHERE last_name REGEXP &#39;FIELD&#39;\n# 这两个结果是相同的\n\nWHERE last_name REGEXP &#39;field|mac|rose&#39;\n#查找姓氏中含有以上三个任意一个的数据\nWHERE last_name REGEXP &#39;^field|mac|rose&#39;\n#查找姓氏中以field开头或含有后两个任意一个的数据\nWHERE last_name REGEXP &#39;field$|mac|rose&#39;\n#查找姓氏中以field结尾或含有后两个任意一个的数据\nWHERE last_name REGEXP &#39;[gim]e&#39;\n#查找姓氏中含有ge、ie、me的数据,后置方括号同理\nWHERE last_name REGEXP &#39;[a-h]e&#39;\n#查找姓氏中有xe的数据，其中x是a到h的任意一个字母,后置方括号同理，-可以代表范围。\n\n​\t\t有时我们需要搜索缺失某种属性的对象，那么我们可以使用IS NULL来查询缺失了某个字段的对象。\nWHERE phone IS NULL \n# phone缺失\nWHERE phone IS NOT NULL \n# phone没有缺失\n\n​\t\t在MySQL中，我们可以通过查看表属性(表旁边的小扳手)来查看表中的字段种类、主键列、数据类型，关系型数据库中，每个表有且只有一个主键列，能够唯一识别表中的记录。默认情况下，表按主键列字段来排序。如果我们想要改变排序规则，那就要使用ORDER BY关键字，可以设置多个属性作为排序规则，并且会按文本顺序确定优先级。\nORDER BY first_name &#x2F;&#x2F;对名字进行升序排序\nORDER BY first_name DESC &#x2F;&#x2F; 对名字进行降序排序\nORDER BY state,first_name \n#根据州来排列，相同州根据名字排列，DESC可以插入到你想要的位置\n\n​\t\t在MySQL中，排序的根据不一定是被SELECT的，例如：\nSELECT first_name,last_name\nFROM customers\nORDER BY points\n\n​\t\t也可以使用别名进行排序，例如：\nSELECT first_name, 10 AS points\nFROM customers\nORDER BY points\n\n​\t\t按列位置排序也是被允许的，但尽量少用,：\nSELECT first_name,last_name\nFROM customers\nORDER BY 1,2\n#先按名字排序，再按姓氏排序\n#若\nSELECT birth_date,first_name,last_name\nFROM customers\nORDER BY 1,2\n#先按出生日期排序，再按姓名排序\n\n​\t\t如果我们只想要几个记录，并不需要那么多记录，那么可以使用LIMIT语句，例如：\nSELECT *\nFROM customers\nLIMIT 3\n# 只需要前三个记录\n\n​\t\t在LIMIT语句中，可以增加offset(偏移量),这在数据分页中特别有用，我们常常为了简洁，会在一页中展示固定数量的记录，用法如下：\nLIMIT 6,3 &#x2F;&#x2F;跳过前六条记录，选择三条\n\n连接内连接​\t\t我们常常把不同的记录放在不同表格中，但有时我们需要选中多张表的记录，可以使用JOIN，在SQL中有内连接和外连接，例子如下：\nSELECT *\nFROM orders\nINNER JOIN customers  &#x2F;&#x2F;INNER可以省略\nON orders.customer_id &#x3D; customers.customers_id\n\n​\t\t上述代码能够把两张表以联合顾客ID相同的记录展现出来，也就是，将两张表中顾客ID相同的记录合为一条记录，在这里，我们需要注意二义性的问题，例如：\nSELECT customer_id  &#x2F;&#x2F;error不明确是哪张表中的顾客ID\nSELECT orders.customer_id &#x2F;&#x2F; correct\nFROM orders\nINNER JOIN customers  &#x2F;&#x2F;INNER可以省略\nON orders.customer_id &#x3D; customers.customers_id\n\n​\t\t为了简化语句，我们可以给表格起别名，例如：\nSELECT *\nFROM orders o\nINNER JOIN customers c &#x2F;&#x2F;INNER可以省略\nON o.customer_id &#x3D; c.customers_id\n\n跨数据库连接​\t\t不仅能够进行内连接，还可以进行跨数据库的连接，只需要在需要被JOIN的表格加上数据库的前缀就能实现,并且只需要给当前未选中的数据库加前缀。\nUSE sql_inventory\nSELECT *\nFROM sql_store.orders o\nJOIN customers c \nON o.customer_id &#x3D; c.customers_id\n\n自连接​\t\t有的时候需要表与自身连接，例如，表中有公司人员的ID，和他们的管理人员的ID，如果你想要把雇员和管理人员的记录联合起来，那么就需要使用自连接，因为管理人员也是公司的一员,同样，这里也需要注意二义性问题。\nUSE sql_hr\nSELECT *\nFROM employees e\nJOIN employees m \nON e.reports_to &#x3D; m.employee_id\n\n两表以上的连接​\t\t两表以上的连接，只需要多加一条JOIN语句就行，同样需要注意二义性问题。\nSELECT *\nFROM orders o\nJOIN customers c\n\tON ...condition\nJOIN status s\n\tON ...condition\n\n复合连接​\t\t有时一个表中没有一个字段能够唯一识别每条记录，这时候就需要用多条字段来唯一识别每一条记录，在表的设置模式中可以看见有两个主键列。\nSELECT *\nFROM order_items oi\nJOIN order_item_notes oin\n\tON oi.order_id &#x3D; oin.order_id\n\tAND oi.product_id &#x3D; oin._product_id\n\n隐式连接​\t\t不出现JOIN关键字也能连接两个表，这里需要使用WHERE，如下：\nSELECT *\nFROM orders\nINNER JOIN customers  &#x2F;&#x2F;INNER可以省略\nON orders.customer_id &#x3D; customers.customers_id\n---\nSELECT *\nFROM orders o,customers c\nWHERE o.customer_id &#x3D; c.customer_id\n\n​\t\t这两种查询是等价的，但最好少用隐式连接，如果漏了WHERE，会造成交叉连接，意思是，第一个表的每一条记录会逐一连接第二个表的每一条记录。\n外连接 OUTER JOINSELECT \n\tc.customer_id,\n\tc.first_name,\n\to._order_id\nFROM customers c\nJOIN orders o  &#x2F;&#x2F;有些customer并没有order\n\tON c.customer_id &#x3D; o.customer_id\nORDER BY c.customer_id\n\n​\t\t这种情况会造成记录缺失，因为也许有些顾客没有订单，这些记录就被忽略了，这就需要用外连接，外连接分为左连接和右连接，LEFT JOIN,RIGHT JOIN。如果使用左连接，那么不管前一个（左表）表中的记录是否符合ON后的条件，都会被返回。如果使用右连接，所有JOIN的表不管是否符合条件，也都会被返回。例如：\nSELECT \n\tc.customer_id,\n\tc.first_name,\n\to._order_id\nFROM customers c\nLEFT JOIN orders o  \n&#x2F;&#x2F;不管customer表中的记录是否符合条件都返回，右连接同理\n\tON c.customer_id &#x3D; o.customer_id\nORDER BY c.customer_id\n\n多表外连接SELECT \n\tc.customer_id,\n\tc.first_name,\n\to._order_id\nFROM customers c\nLEFT JOIN orders o  \n&#x2F;&#x2F;不管customer表中的记录是否符合条件都返回，右连接同理\n\tON c.customer_id &#x3D; o.customer_id\nLEFT JOIN shippers sh\n\tON o.shipper_id &#x3D; sh.shipper_id\nORDER BY c.customer_id\n\n​\t\t最好不要同时使用两种连接，只选择左连接，增强可读性。\n自外连接​\t\t自连接和外连接并不是不能同时出现，相反，有许多场景需要这么做，这时只需要加一个LEFT &#x2F; RIGHT就行。\nUSE sql_hr\nSELECT *\nFROM employees e\nLEFT JOIN employees m \n\tON e.reports_to &#x3D; m.employee_id\n\nUSING语句SELECT \n\tc.customer_id,\n\tc.first_name,\n\to._order_id\nFROM customers c\nLEFT JOIN orders o  \n&#x2F;&#x2F;不管customer表中的记录是否符合条件都返回，右连接同理\n\tON c.customer_id &#x3D; o.customer_id\nORDER BY c.customer_id\n\n​\t\t在上面这串代码中，ON后的条件中，选择的两个表的字段都是customer_id，我们可以使用USING关键字来简化这一语句,内连接和外连接都可以使用，但只能在两表的字段完全相同时使用。\nSELECT \n\tc.customer_id,\n\tc.first_name,\n\to._order_id\nFROM customers c\nLEFT JOIN orders o  \n&#x2F;&#x2F;不管customer表中的记录是否符合条件都返回，右连接同理\n\tUSING (customer_id)\nORDER BY c.customer_id\n\n​\t\t之前我们遇到过复合主键的情况，USING也可以使用，只需要在USING后的括号中加入条件，并用逗号分割就行。如下：\nSELECT *\nFROM order_items oi\nJOIN order_item_notes oin\n\tUSING (order_id,product_id)\n\n自然连接​\t\t自然连接是一种非常简便的连接，DBMS会自己看着办，基于共同的列连接,尽量少用。\nSELECT \n\to.order_id\n\tc.first_name\nFROM orders o\nNATURAL JOIN customers\n\n交叉连接​\t\t意思就是让一个表中的每一条记录都和另一个表中的全部记录连接一次。使用CROSS JOIN，在需要排列组合的时候用处很大。\nSELECT \n\to.order_id\n\tc.first_name\nFROM orders o\nCROSS JOIN customers\n\n​\t\t还可以使用隐式交叉连接。例如：\nSELECT \n\to.order_id\n\tc.first_name\nFROM orders o,customers c\n\n\n联合​\t\t之前所用的连接都是将列连接在一起，同样，在SQL中，也可以让行联合在一起，这需要使用UNION,在两段查询语句之间加入UNION就可以了，需要注意的是，指定返回的列数需要相同，并且列名是根据第一段查询来设定的。如下：\nSELECT \n\torder_id,\n\torder_date,\n\t&#39;Active&#39; AS status\nFROM orders\nWHERE order_date &gt;&#x3D; &#39;2019-01-01&#39;\nUNION\nSELECT \n\torder_id,\n\torder_date.\n\t&#39;Archived&#39; AS status\nFROM orders\nWHERE order_date &lt; &#39;2019-01-01&#39;\n\n列属性​\t\t每一个字段都有自己的数据类型(datatype)，例如,customer_id只接受INT类型的数据，name只接受VARCHAR类型的数据，在数据类型的后面，往往会跟有一个括号，表示这个数据类型最多能够容纳多少位该数据类型，当你的数据不足()中标识的容纳最大量，DBMS会为你自动填充。需要注意的是，一些数据类型不会为你填满，而是认为是可变的(variable)，例如VARCHAR(50),如果你输入5个字符，那就存5个字符，不会占用多余的空间，但如果是CHAR(50),那么DBMS会自动为你填充满50个字符。 \n​\t\t以下是几种常见的列属性：\n\n\n\nPK(主键)\n这一列的值能唯一标识每一条记录\n\n\n\nNN(非空值)\n这一列不能为空值\n\n\nAI(自动递增)\n这一列的数据在插入时会自动递增，常被用于主键列\n\n\nDEFAULT\n默认值\n\n\nUQ\n唯一索引，每一条记录的UQ字段数据都不同\n\n\nZF\n自动填充0，例如int(4)，输入1会补充为0001\n\n\nBIN\n二进制数据\n\n\nUN\n标识无符号数\n\n\n插入​\t\t插入单行，需要使用到INSERT INTO,VALUES关键字，语法如下：\nINSERT INTO table\nVALUES (每一列的值，如果启动AI，则可以不用输入该字段)\n----\nINSERT INTO customers \n&#x2F;&#x2F;第一种，将记录中每一个字段的数据逐个列出\nVALUES(DEFAULT,\n      &#39;John&#39;,\n      &#39;Smith&#39;,\n      &#39;1990-01-01&#39;,\n      &#39;NULL&#39;)\n----\nINSERT INTO customers(\n\tfirst_name,\n\tlast_name,\n\tbirth_date,\n    address,\n    city,\n    state)\nVALUES()&#x2F;&#x2F;只需要给上述字段给定数据，按顺序陈列，其他能取默认值的数据都取默认值。\n\n​\t\t插入多行，只需要增加VALUES的括号数量。例如：\nINSERT INTO customers(\n\tfirst_name,\n\tlast_name,\n\tbirth_date,\n    address,\n    city,\n    state)\nVAULES(),\n\t  ()\n\n​\t\t插入分层行，也就是往多张表中插入数据，试想下面一个场景，我们有两个表,order和order_items,order表记录的是订单的顾客，订单号，状态等等，而order_items中包含着订单的具体信息，例如产品号，产品单价等等，一个订单号可以对应order_items中的多个记录，同一个订单号可以对应多个产品，可以想象他们是一对母子关系，这时候就需要往多张表中插入数据。请看以下的代码：\nINSERT INTO orders (customers_id,order_date,status)\nVALUES(1,&#39;1990-01-01&#39;,1)\n&#x2F;&#x2F;这里可以使用MYSQL中的内置函数，LAST_INSERT_ID(),能够返回插入新行时MYSQL生成的ID。\nINSERT INTO order_items\nVALUES(LAST_INSERT_ID(),1,1,2.95),\n\t  (LAST_INSERT_ID(),2,1,3.95)\n\n创造 复制表​\t\t如果要把一个表的所有数据复制到另一张表，不用写那么多的INSERT INTO,如下：\nCREATE TABLE orders_archived AS\nSELECT * FROM orders\n\n​\t\t这段代码能够创造一张名为ORDER_ARCHIVED的表，并把orders的数据全部复制到这张表中，但当我们打开设计模式的时候，会发现相关的列属性会缺失，例如新表是不存在主键列的，AI也没有启用。我们将SELECT * FROM orders这类语句称为子查询，是部分属于另外一段SQL语句的选择语句，子查询也可以用在INSERT INTO语句下，例如：\nINSERT INTO orders_archived\nSELECT * \nFROM orders\nWHERE order_date &lt; &#39;2009-01-01&#39;\n\n更新记录​\t\t更新记录可以使用UPDATE 和SET关键字，例如\nUPDATE invoices\nSET payment_total &#x3D; 10\nWHERE invoice_id &#x3D; 1\n\n​\t\t如果想要更新多行，语法是一样的，但是条件需要更加普遍，例如：\nUPDATE invoices\nSET \n\tpayment_total &#x3D; invoice_total * 0.5\nWHERE\n\tclient_id &#x3D; 3 &#x2F;&#x2F;所有客户号为3的记录都被更新了\nWHERE client_id IN (3,4) &#x2F;&#x2F;IN关键字也可以使用\n\nUPDATE子查询​\t\t子查询一样可以应用在UPDATE中，当你不能直接知道条件的时候，就可以使用子查询，例如：\nUPDATE invoices\nSET \n\tpayment_total &#x3D; invoice_total * 0.5\n\tpayment_total &#x3D; due_date\nWHERE client_id &#x3D;\n\t(SELECT client_id\n     FROM clients\n     WHERE name &#x3D; &#39;Myworks&#39;)\n     &#x2F;&#x2F;作为WHERE的条件需要括起来\n\n删除数据​\t\t很简单，但删除数据需要非常小心,同样也可以使用子查询，这里就不再赘述。\nDELETE FROM invoices\nWHERE invoice_id &#x3D; 1\n\n事务​\t\t事务具有原子性，不可拆分。例如进行交易，付出去的钱和收到的钱是一样并且是同时进行的。这是事务的一致性。每个事务是不懂其他事务的状态的，这是隔离性，也读不到正在执行中的变化。成功就提交到数据库中保存，这是事务的持久性，ACID。\n​\t\t事务有几个状态。活动状态，是初始状态，执行中。部分提交状态，最后一条语句执行后。失败状态，无法继续执行。终止状态，数据库回到开始之前的状态。最后是提交状态。\n","slug":"SQL","date":"2023-02-23T08:48:00.000Z","categories_index":"","tags_index":"SQL,MySQL","author_index":"iroha"},{"id":"f8c956dcab6a4b279bbeaf03bf015ae7","title":"字典树(Trie)","content":"性质\n每一个节点都包含一个字符。\n根节点到某一个节点的路径所经过的字符连接起来，就是该节点对应的字符串。\n任意节点的子节点包含的字符不同。\n遇到Terminal Point，说明组成的字符对于当前工作有意义。\n\n用例\n搜索自动补全\n最长前缀匹配\n词频统计\n\n最基础实现class Trie &#123;\n    Trie* children[26];\n    bool isEnd;\n    Trie* searchPrefix(string prefix) &#123;\n        Trie* node &#x3D; this;\n        for (char ch : prefix) &#123;\n            ch -&#x3D; &#39;a&#39;;\n            if (node-&gt;children[ch] &#x3D;&#x3D; nullptr) &#123;\n                return nullptr;\n            &#125;\n            node &#x3D; node-&gt;children[ch];\n        &#125;\n        return node;\n    &#125;\n\npublic:\n    Trie() : isEnd(false) &#123;\n        for(int i &#x3D; 0;i &lt; 26;i++)&#123;\n            children[i] &#x3D; nullptr;\n        &#125;\n    &#125;\n\n    void insert(string word) &#123;\n        Trie* node &#x3D; this;\n        for (char ch : word) &#123;\n            ch -&#x3D; &#39;a&#39;;\n            if (node-&gt;children[ch] &#x3D;&#x3D; nullptr) &#123;\n                node-&gt;children[ch] &#x3D; new Trie();\n            &#125;\n            node &#x3D; node-&gt;children[ch];\n        &#125;\n        node-&gt;isEnd &#x3D; true;\n    &#125;\n\n    bool search(string word) &#123;\n        Trie* node &#x3D; this-&gt;searchPrefix(word);\n        return node !&#x3D; nullptr &amp;&amp; node-&gt;isEnd;\n    &#125;\n\n    bool startsWith(string prefix) &#123;\n        return this-&gt;searchPrefix(prefix) !&#x3D; nullptr;\n    &#125;\n&#125;;\n\n\n\n","slug":"字典树","date":"2023-02-22T15:10:00.000Z","categories_index":"","tags_index":"数据结构,Leetcode","author_index":"iroha"}]