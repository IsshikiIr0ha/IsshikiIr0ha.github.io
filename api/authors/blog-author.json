{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}},"post_list":[{"title":"单调栈","uid":"0614f2a1b2d44b47b9d291cad158b954","slug":"单调栈","date":"2023-03-18T16:40:00.000Z","updated":"2023-03-18T16:42:06.243Z","comments":true,"path":"api/articles/单调栈.json","keywords":null,"cover":[],"text":" 原理单调栈常常用于寻找离元素最近的一个比当前值大(小)的元素，若我们需要寻找比当前nums[i]下一个更大的元素，则需要从右往左遍历，由于栈后进先出的特性，nums[i]右边的数会在栈顶。我们需要维持一个递增栈(从栈顶到栈底递增)，保证栈里的数比当前数大，就需要当nums[i]...","link":"","photos":[],"count_time":{"symbolsCount":577,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","count":5,"path":"api/tags/Leetcode.json"},{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"feature":true},{"title":"几道位运算的题","uid":"115e88fbdb7de27d1adaee0a1c94eec9","slug":"位运算","date":"2023-03-12T11:36:00.000Z","updated":"2023-03-12T12:04:50.915Z","comments":true,"path":"api/articles/位运算.json","keywords":null,"cover":[],"text":"Leetcode 231 2的幂给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 bool isPowerOfTwo(int n) &#123;...","link":"","photos":[],"count_time":{"symbolsCount":826,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"feature":true},{"title":"C++ 类","uid":"a98ce169e82ba10a329e77dc3bdf4dba","slug":"C-类","date":"2023-03-11T08:45:00.000Z","updated":"2023-03-12T05:32:14.870Z","comments":true,"path":"api/articles/C-类.json","keywords":null,"cover":null,"text":"C++ 类​ 类的基本思想是数据抽象和封装，依赖于接口和实现分离的编程技术。用户只能使用接口而无法访问实现部分。 定义一个类​ 定义之前首先我们要设计出这个类，以Sales_data类为例，我们需要有以下接口： 一个isbn成员函数，返回对象的ISBN编号。 一个combine成...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}},"feature":true},{"title":"前缀和与差分","uid":"f65c2271ed43cdf14e2eea3c0c440d44","slug":"前缀和与差分","date":"2023-03-10T09:40:00.000Z","updated":"2023-03-10T10:30:16.589Z","comments":true,"path":"api/articles/前缀和与差分.json","keywords":null,"cover":[],"text":"前缀和与差分 例题523 连续的子数组给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组： 子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。 如果存在一个整...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}},{"title":"基础算法模板(1)","uid":"d4eb8ac478f9b1540ad79d6e8d3f28dd","slug":"基础算法模板-1","date":"2023-03-09T11:06:00.000Z","updated":"2023-03-10T09:45:21.399Z","comments":true,"path":"api/articles/基础算法模板-1.json","keywords":null,"cover":[],"text":"快排void quick_sort(int q[],int l,int r)&#123; if (l&gt;&#x3D;r)&#123; &#x2F;&#x2F;判断输入错误和数组大小为1 return; &#125; int x &#x3D; q[(l+r)&gt;&gt;1]...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}},{"title":"环形链表题","uid":"7e07234faada42c308f491eefec54e74","slug":"环形链表题","date":"2023-02-25T15:05:00.000Z","updated":"2023-02-25T23:48:24.132Z","comments":true,"path":"api/articles/环形链表题.json","keywords":null,"cover":[],"text":"141.环形链表I，142.环形链表II141.环形链表I给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","count":5,"path":"api/tags/Leetcode.json"},{"name":"链表","slug":"链表","count":3,"path":"api/tags/链表.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}},{"title":"2.两数之和","uid":"ccde5a49b40a5476a862c22787b0daae","slug":"2-两数之和","date":"2023-02-25T14:50:00.000Z","updated":"2023-02-25T14:56:45.249Z","comments":true,"path":"api/articles/2-两数之和.json","keywords":null,"cover":[],"text":"2.两数之和题目：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 分析：简单题，按所给示例，因为...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","count":5,"path":"api/tags/Leetcode.json"},{"name":"链表","slug":"链表","count":3,"path":"api/tags/链表.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}},{"title":"网络信息安全","uid":"4eed6726322cbd1240d9eae47dec8b49","slug":"网络信息安全","date":"2023-02-23T08:53:00.000Z","updated":"2023-02-23T09:07:37.301Z","comments":true,"path":"api/articles/网络信息安全.json","keywords":null,"cover":[],"text":"密码学第二章密码学基本术语​ Key：密钥，对加密和解密过程进行控制的参数。 ​ Cipher：加密方法。 ​ Encipher：加密。将明文转换为密文。 ​ Decipher：解密。将密文还原成明文。 ​ Plaintext：明文。 ​ Ciphertext：密文。 ​ 大多数...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"密码学","slug":"密码学","count":1,"path":"api/tags/密码学.json"},{"name":"网络安全","slug":"网络安全","count":1,"path":"api/tags/网络安全.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}},{"title":"SQL","uid":"6fc8774f334f99b8964d2d8c2cdc313c","slug":"SQL","date":"2023-02-23T08:48:00.000Z","updated":"2023-02-23T09:08:08.266Z","comments":true,"path":"api/articles/SQL.json","keywords":null,"cover":null,"text":"基于MySQL的极入门笔记简介DB DBMS SQL之间的关系： ​ DB是Data Base，是数据库的缩写，在硬盘上以文件的形式存在。DBMS是Data Base Management System（数据库管理系统）的缩写，例如MySQL、Oracle、DB2等就是一个DBM...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"SQL","slug":"SQL","count":1,"path":"api/tags/SQL.json"},{"name":"MySQL","slug":"MySQL","count":1,"path":"api/tags/MySQL.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}},{"title":"NLP处理层次","uid":"9a8eeb2e28c3ae10efc64a62fe7b0855","slug":"test1","date":"2023-02-22T15:10:00.000Z","updated":"2023-02-23T13:10:50.429Z","comments":true,"path":"api/articles/test1.json","keywords":null,"cover":[],"text":" 输入源一般是语音，文本和图像，语音和图像一般通过语音识别和光学字符识别转换为文本，这一步称为文本处理。 词法分析一般有分词，词性标注和命名实体识别三个步骤，分词是将文本分隔为有意义的词汇，再通过词性标注确定词语类别并消除歧义，再通过命名实体识别标出较长的专有名词。 信息抽取，在...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}},{"title":"几道链表简单题","uid":"34f0de872ee3165f6bfb3bec408d89cb","slug":"test2","date":"2023-02-22T15:10:00.000Z","updated":"2023-02-24T16:10:28.608Z","comments":true,"path":"api/articles/test2.json","keywords":null,"cover":null,"text":"Leetcode 203 移除链表元素给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 ​ 唯一需要思考的点是当删除的元素是第一个元素怎么办。我们可以设置一个虚拟头结点，他的next是原本...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","count":5,"path":"api/tags/Leetcode.json"},{"name":"链表","slug":"链表","count":3,"path":"api/tags/链表.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}},{"title":"字典树(Trie)","uid":"f8c956dcab6a4b279bbeaf03bf015ae7","slug":"字典树","date":"2023-02-22T15:10:00.000Z","updated":"2023-03-06T02:50:34.868Z","comments":true,"path":"api/articles/字典树.json","keywords":null,"cover":null,"text":"性质 每一个节点都包含一个字符。 根节点到某一个节点的路径所经过的字符连接起来，就是该节点对应的字符串。 任意节点的子节点包含的字符不同。 遇到Terminal Point，说明组成的字符对于当前工作有意义。 用例 搜索自动补全 最长前缀匹配 词频统计 最基础实现class Tr...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","count":5,"path":"api/tags/Leetcode.json"},{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"author":{"name":"iroha","slug":"blog-author","avatar":"/images/avater.png","link":"/","description":"真不是我想摆烂","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/5325008"},"zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/zhong-ji-pi-pi-61"},"github":{"icon":"/svg/github.svg","link":"https://github.com/IsshikiIr0ha"}}}}}],"categories":0,"tags":0,"word_count":"35k","post_count":12}